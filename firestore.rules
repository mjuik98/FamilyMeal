rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    function signedIn() {
      return request.auth != null;
    }

    function userDocPath(uid) {
      return /databases/$(database)/documents/users/$(uid);
    }

    function hasUserProfile() {
      return signedIn() && exists(userDocPath(request.auth.uid));
    }

    function currentUserRole() {
      return hasUserProfile() ? get(userDocPath(request.auth.uid)).data.role : null;
    }

    function validRole(role) {
      return role in ['아빠', '엄마', '딸', '아들'];
    }

    function validMealType(type) {
      return type in ['아침', '점심', '저녁', '간식'];
    }

    function hasValidParticipantList(mealData) {
      return mealData.userIds is list
        && mealData.userIds.size() > 0
        && mealData.userIds.hasOnly(['아빠', '엄마', '딸', '아들']);
    }

    function isMealParticipant(mealData) {
      return hasUserProfile()
        && (
          (mealData.userIds is list && mealData.userIds.hasAny([currentUserRole()]))
          || (mealData.userId is string && mealData.userId == currentUserRole())
        );
    }

    function isMealOwner(mealData) {
      return signedIn() && mealData.ownerUid is string && mealData.ownerUid == request.auth.uid;
    }

    function isLegacyMeal(mealData) {
      return !(mealData.ownerUid is string);
    }

    function canReadMeal(mealData) {
      return hasUserProfile();
    }

    function validMealDocument(mealData) {
      return mealData.keys().hasOnly([
          'ownerUid', 'userId', 'userIds', 'keywords', 'imageUrl', 'description', 'type', 'timestamp', 'commentCount'
        ])
        && mealData.ownerUid is string
        && mealData.ownerUid.size() > 0
        && hasValidParticipantList(mealData)
        && mealData.description is string
        && mealData.description.size() > 0
        && validMealType(mealData.type)
        && mealData.timestamp is timestamp
        && mealData.commentCount is int
        && mealData.commentCount >= 0
        && (!('userId' in mealData) || validRole(mealData.userId));
    }

    function canEditMealBody() {
      return validMealDocument(request.resource.data)
        && (
          isMealOwner(resource.data)
          || (isLegacyMeal(resource.data) && isMealParticipant(resource.data))
        )
        && (
          request.resource.data.ownerUid == resource.data.ownerUid
          || (isLegacyMeal(resource.data) && request.resource.data.ownerUid == request.auth.uid)
        );
    }

    function canEditCommentCountOnly() {
      return hasUserProfile()
        && request.resource.data.diff(resource.data).affectedKeys().hasOnly(['commentCount'])
        && request.resource.data.commentCount is int
        && request.resource.data.commentCount >= 0;
    }

    function validUserProfile(profileData) {
      return profileData.keys().hasOnly(['uid', 'email', 'displayName', 'role'])
        && profileData.uid is string
        && profileData.uid == request.auth.uid
        && profileData.email is string
        && request.auth.token.email is string
        && profileData.email == request.auth.token.email
        && (!('displayName' in profileData) || profileData.displayName == null || profileData.displayName is string)
        && (profileData.role == null || validRole(profileData.role));
    }

    match /users/{uid} {
      allow read: if signedIn() && request.auth.uid == uid;

      allow create: if signedIn()
        && request.auth.uid == uid
        && validUserProfile(request.resource.data);

      allow update: if signedIn()
        && request.auth.uid == uid
        && validUserProfile(request.resource.data)
        && request.resource.data.uid == resource.data.uid
        && request.resource.data.email == resource.data.email;

      allow delete: if signedIn() && request.auth.uid == uid;
    }

    match /meals/{mealId} {
      allow read: if canReadMeal(resource.data);

      allow create: if hasUserProfile()
        && validMealDocument(request.resource.data)
        && request.resource.data.ownerUid == request.auth.uid
        && request.resource.data.userIds.hasAny([currentUserRole()]);

      allow update: if hasUserProfile() && (canEditMealBody() || canEditCommentCountOnly());

      allow delete: if hasUserProfile()
        && (
          isMealOwner(resource.data)
          || (isLegacyMeal(resource.data) && isMealParticipant(resource.data))
        );

      match /comments/{commentId} {
        function parentMealPath() {
          return /databases/$(database)/documents/meals/$(mealId);
        }

        function parentMealData() {
          return get(parentMealPath()).data;
        }

        function canAccessParentMeal() {
          return exists(parentMealPath()) && canReadMeal(parentMealData());
        }

        allow read: if canAccessParentMeal();

        allow create: if canAccessParentMeal()
          && request.resource.data.keys().hasOnly(['author', 'authorUid', 'text', 'createdAt', 'updatedAt'])
          && validRole(request.resource.data.author)
          && request.resource.data.author == currentUserRole()
          && request.resource.data.authorUid == request.auth.uid
          && request.resource.data.text is string
          && request.resource.data.text.size() > 0
          && request.resource.data.createdAt is timestamp
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.createdAt == request.resource.data.updatedAt;

        allow update: if canAccessParentMeal()
          && resource.data.authorUid == request.auth.uid
          && request.resource.data.keys().hasOnly(['author', 'authorUid', 'text', 'createdAt', 'updatedAt'])
          && request.resource.data.author == resource.data.author
          && request.resource.data.authorUid == resource.data.authorUid
          && request.resource.data.createdAt == resource.data.createdAt
          && request.resource.data.text is string
          && request.resource.data.text.size() > 0
          && request.resource.data.updatedAt is timestamp
          && request.resource.data.updatedAt >= resource.data.updatedAt;

        allow delete: if canAccessParentMeal() && resource.data.authorUid == request.auth.uid;
      }
    }
  }
}
